#[contract]
mod PartyDAO {
    use starknet::get_caller_address;
    use starknet::ContractAddress;
    use openzeppelin::token::erc20::IERC20;
    use jediswap::pool::IPool;  // Using JediSwap as the AMM

    // Storage
    struct Storage {
        manager: ContractAddress,
        treasury: ContractAddress,
        dao_token: ContractAddress,
        lp_token: ContractAddress,
        dex_pool: ContractAddress,
        fundraise_target: u256,
        min_pool_price: u256,
        expiry_timestamp: u64,
        total_staked: u256,
        reward_per_share: u256,
        trading_fees: u256,
        staking_rewards: u256,
        manager_fees: u256,
        is_expired: bool,
        trading_active: bool,
    }

    // Events
    #[event]
    fn DAOInitialized(
        manager: ContractAddress,
        treasury: ContractAddress,
        dao_token: ContractAddress,
        fundraise_target: u256
    ) {}

    #[event]
    fn PoolCreated(
        pool_address: ContractAddress,
        lp_token: ContractAddress,
        initial_liquidity: u256
    ) {}

    #[event]
    fn Staked(staker: ContractAddress, amount: u256) {}

    #[event]
    fn Unstaked(staker: ContractAddress, amount: u256, reward: u256) {}

    // Constructor
    #[constructor]
    fn constructor(
        manager: ContractAddress,
        dao_token: ContractAddress,
        fundraise_target: u256,
        min_pool_price: u256,
        expiry_timestamp: u64,
    ) {
        // Initialize storage
        self.manager.write(manager);
        self.dao_token.write(dao_token);
        self.fundraise_target.write(fundraise_target);
        self.min_pool_price.write(min_pool_price);
        self.expiry_timestamp.write(expiry_timestamp);
        self.total_staked.write(0);
        self.reward_per_share.write(0);
        self.trading_fees.write(0);
        self.staking_rewards.write(0);
        self.manager_fees.write(0);
        self.is_expired.write(false);
        self.trading_active.write(false);

        // Emit initialization event
        DAOInitialized(manager, self.treasury.read(), dao_token, fundraise_target);
    }

    // External functions
    #[external]
    fn create_pool(
        eth_amount: u256,
        token_amount: u256,
        pool_factory: ContractAddress
    ) {
        // Only manager can create pool
        assert(get_caller_address() == self.manager.read(), 'UNAUTHORIZED');
        assert(!self.trading_active.read(), 'ALREADY_ACTIVE');

        // Create pool using JediSwap factory
        let pool = IJediFactory::create_pool(
            pool_factory,
            self.dao_token.read(),
            ETH_ADDRESS,  // Using ETH as the paired token
            FEE_TIER_MEDIUM  // 0.3% fee tier
        );

        // Add initial liquidity
        let eth_token = IERC20::new(ETH_ADDRESS);
        let dao_token = IERC20::new(self.dao_token.read());

        // Approve tokens
        eth_token.approve(pool, eth_amount);
        dao_token.approve(pool, token_amount);

        // Add liquidity
        let (lp_token_addr, lp_amount) = IPool::add_liquidity(
            pool,
            eth_amount,
            token_amount,
            0,  // Min ETH
            0,  // Min tokens
            get_caller_address(),
            block_timestamp() + 1800  // 30 min deadline
        );

        // Update storage
        self.dex_pool.write(pool);
        self.lp_token.write(lp_token_addr);
        self.trading_active.write(true);

        // Emit event
        PoolCreated(pool, lp_token_addr, lp_amount);
    }

    #[external]
    fn stake_lp(amount: u256) {
        let caller = get_caller_address();
        assert(self.trading_active.read(), 'POOL_NOT_ACTIVE');

        // Update rewards before staking
        self.update_rewards();

        // Transfer LP tokens from user
        let lp_token = IERC20::new(self.lp_token.read());
        lp_token.transfer_from(caller, self, amount);

        // Update staking info
        let mut staking_info = self.staking_accounts.read(caller);
        staking_info.amount += amount;
        staking_info.reward_debt = self.calculate_reward_debt(
            amount,
            self.reward_per_share.read()
        );
        self.staking_accounts.write(caller, staking_info);
        self.total_staked.write(self.total_staked.read() + amount);

        // Emit event
        Staked(caller, amount);
    }

    #[external]
    fn unstake_lp(amount: u256) {
        let caller = get_caller_address();
        let mut staking_info = self.staking_accounts.read(caller);
        assert(staking_info.amount >= amount, 'INSUFFICIENT_STAKE');

        // Update rewards before unstaking
        self.update_rewards();

        // Calculate pending rewards
        let pending_reward = self.calculate_pending_reward(
            staking_info.amount,
            self.reward_per_share.read(),
            staking_info.reward_debt
        );

        // Transfer LP tokens back
        let lp_token = IERC20::new(self.lp_token.read());
        lp_token.transfer(caller, amount);

        // Update staking info
        staking_info.amount -= amount;
        staking_info.reward_debt = self.calculate_reward_debt(
            staking_info.amount,
            self.reward_per_share.read()
        );
        self.staking_accounts.write(caller, staking_info);
        self.total_staked.write(self.total_staked.read() - amount);

        // Transfer rewards if any
        if pending_reward > 0 {
            let reward_token = IERC20::new(self.dao_token.read());
            reward_token.transfer(caller, pending_reward);
        }

        // Emit event
        Unstaked(caller, amount, pending_reward);
    }

    #[external]
    fn collect_fees() {
        assert(get_caller_address() == self.manager.read(), 'UNAUTHORIZED');

        let trading_fees = self.trading_fees.read();
        let staking_rewards = self.staking_rewards.read();
        let manager_fees = self.manager_fees.read();

        // Reset accumulators
        self.trading_fees.write(0);
        self.staking_rewards.write(0);
        self.manager_fees.write(0);

        if trading_fees > 0 {
            // Transfer fees to manager
            let fee_token = IERC20::new(ETH_ADDRESS);
            fee_token.transfer(self.manager.read(), trading_fees);
        }
    }

    // Internal functions
    #[internal]
    fn update_rewards() {
        let total_staked = self.total_staked.read();
        if total_staked == 0 {
            return;
        }

        let staking_rewards = self.staking_rewards.read();
        self.reward_per_share.write(
            self.reward_per_share.read() + (staking_rewards / total_staked)
        );
        self.staking_rewards.write(0);
    }

    #[internal]
    fn calculate_reward_debt(amount: u256, reward_per_share: u256) -> u256 {
        amount * reward_per_share
    }

    #[internal]
    fn calculate_pending_reward(
        amount: u256,
        reward_per_share: u256,
        reward_debt: u256
    ) -> u256 {
        amount * reward_per_share - reward_debt
    }
}

// Helper structs
#[derive(Drop, Serde)]
struct StakingInfo {
    amount: u256,
    reward_debt: u256
}
